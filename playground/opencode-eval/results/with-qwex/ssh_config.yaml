vars:
  ssh_user: "testuser"
  ssh_host: "localhost"
  ssh_port: "2345"
  ssh_key: "/Users/quatton/Documents/GitHub/qwex/playground/opencode-eval/demo/.ssh/id_rsa"
  repo_name: "demo"

tasks:
  ssh:
    desc: "Connects to the remote SSH server and runs the provided arguments as a command."
    vars:
      remote_cmd: '"$@"'
    cmd: |
      ssh -i "{{ vars.ssh_key }}" -p {{ vars.ssh_port }} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{ vars.ssh_user }}@{{ vars.ssh_host }} {{ vars.remote_cmd }}

  run:
    desc: "Syncs git repo, creates remote worktree, and executes command."
    cmd: |
      # 1. Check Local Git Status
      if [ -n "$(git status --porcelain)" ]; then
        echo "Error: Git working tree is not clean. Please commit or stash changes."
        exit 1
      fi

      RUN_ID=$(date +%Y%m%d%H%M%S)-$(openssl rand -hex 4)
      CMD="$@"
      COMMIT_HASH=$(git rev-parse HEAD)

      # 2. Sync Repo
      # Ensure remote bare repo exists
      REPO_DIR=".qwex/repos/{{ vars.repo_name }}.git"
      # We check if HEAD exists to avoid re-initing unnecessarily, though init is safe.
      {{ tasks.ssh.inline(remote_cmd='"mkdir -p $REPO_DIR && [ ! -d $REPO_DIR/HEAD ] && git init --bare $REPO_DIR || true"') }}

      # Push to remote
      REMOTE_REPO_PATH="/home/{{ vars.ssh_user }}/$REPO_DIR"
      GIT_SSH_COMMAND="ssh -i {{ vars.ssh_key }} -p {{ vars.ssh_port }} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" \
      git push "ssh://{{ vars.ssh_user }}@{{ vars.ssh_host }}/$REMOTE_REPO_PATH" HEAD:refs/heads/qwex-sync -f > /dev/null 2>&1

      if [ $? -ne 0 ]; then
        echo "Error: Failed to sync git repository to remote."
        exit 1
      fi

      # 3. Setup Remote Environment (Logs & Worktree)
      REMOTE_RUN_DIR="\$HOME/.qwex/runs/$RUN_ID"
      WORKTREE_DIR="$REMOTE_RUN_DIR/worktree"

      # Create log/meta structure
      SETUP_CMD="mkdir -p $REMOTE_RUN_DIR/logs $REMOTE_RUN_DIR/meta && echo \"$CMD\" > $REMOTE_RUN_DIR/meta/command"
      {{ tasks.ssh.inline(remote_cmd='"$SETUP_CMD"') }}

      # Create worktree from the bare repo
      # We use the full path for the bare repo in the worktree command
      # git --git-dir=... worktree add ...
      WORKTREE_CMD="git --git-dir=\$HOME/$REPO_DIR worktree add -d $WORKTREE_DIR $COMMIT_HASH"
      {{ tasks.ssh.inline(remote_cmd='"$WORKTREE_CMD"') }}

      # 4. Execute in Worktree
      # We enter the worktree, run the command, and pipe output to the log file
      # We assume the command (e.g. 'uv run main.py') works relative to the repo root
      EXEC_CMD="cd $WORKTREE_DIR && { $CMD; } 2>&1 | tee $REMOTE_RUN_DIR/logs/main.log"
      {{ tasks.ssh.inline(remote_cmd='"$EXEC_CMD"') }}

      echo "RUN_ID=$RUN_ID"

  retrieve:
    desc: "Retrieves the run directory from remote to local."
    vars:
      run_id: ""
    cmd: |
      if [ -z "{{ vars.run_id }}" ]; then
        if [ $# -eq 0 ]; then
          echo "Error: Run ID is required."
          exit 1
        fi
        RUN_ID="$1"
      else
        RUN_ID="{{ vars.run_id }}"
      fi

      LOCAL_RUN_DIR="$HOME/.qwex/runs/$RUN_ID"
      mkdir -p "$LOCAL_RUN_DIR"

      # Use scp to recursively copy the remote directory content to local
      # We exclude the worktree itself if it's large? The instructions don't say to exclude it.
      # But 'worktree' is a directory inside the run dir now.
      # We probably only care about logs and meta for verification.
      # But scp -r copies everything.

      scp -r -i "{{ vars.ssh_key }}" -P {{ vars.ssh_port }} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{ vars.ssh_user }}@{{ vars.ssh_host }}:.qwex/runs/$RUN_ID/* "$LOCAL_RUN_DIR/"
